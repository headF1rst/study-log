- 트랜잭션
    - 하나의 논리적 작업 단위를 구성하는 연산들의 집합
- 트랜잭션의 성질 (ACID)
    - 원자성 (Atomicity)
        - 트랜잭션의 모든 연산이 정상적으로 완료되거나 전혀 수행되지 않아야 한다.
    - 일관성 (Consistency)
        - 데이터베이스의 제약 조건들을 지켜야 한다.
            - 제약 조건
                - 데이터의 무결성을 지키기 위해, 데이터를 입력 받을 때 실행되는 검사 규칙
    - 독립성 (Isolation)
        - 여러 트랜잭션이 동시 수행되더라도 서로의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.
            - 독립성을 지키기 위한 방법
            - 모든 트랜잭션을 순차적으로 수행
            - `DBMS는 병렬적으로 수행하면서도 일렬 수행과 같은 결과를 보장하는 방식을 제공한다.`
                - 트랜잭션의 격리 수준
    - 지속성 (Durability)
        - 트랜잭션이 커밋되고 나면 장애가 발생되더라도 데이터가 보존되어야 한다.

## DBMS의 트랜잭션 관리 전략

![dbms1](https://d2.naver.com/content/images/2015/06/helloworld-407507-1.png)

- 페이지 버퍼
    - 메인 메모리에 유지하는 `페이지들을 관리하는 모듈.`
    - 버퍼 관리 정책에 따라, 트랜잭션의 UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 된다.
    - 데이터베이스는 데이터를 비휘발성인 디스크에 저장하고 일부를 메인 메모리에 유지한다.
    - DBMS는 데이터를 고정 길이의 페이지로 저장.
    - 디스크에서 읽거나 쓸 때에 페이지 단위로 입출력이 이루어진다.

## UNDO

- 연산 수행중, 수정된 페이지들이 페이지 버퍼의 `버퍼 교체` 알고리즘에 따라서 디스크에 출력될 수 있다.
- `버퍼 교체`는 버퍼의 상태에 따라서 결정되며 임의의 방식으로 일어나게 된다.
- (아직 완료되지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있다.)
- 해당 트랜잭션이 비정상적으로 종료된다면 트랜잭션이 변경한 페이지들도 복구 되어야 한다 - **UNDO**

### UNDO 정책

버퍼 관리 정책

- STEAL ⭐️
    - 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
    - 트랜잭션 커밋 이전에 수정된 페이지가 디스크에 써질 수 있기 때문에 UNDO 로깅과 복구가 필요
- ¬STEAL
    - 트랜잭션 종료 시점까지 수정된 페이지들을 버퍼에 유지하는 정책
    - 메모리 버퍼의 크기가 매우 커야만 한다.

## REDO

- 커밋한 트랜잭션의 수정은 어떤 경우에도 유지되어야 한다.
- 트랜잭션 종료 시점에 해당 트랜잭션이 수정한 페이지들을 디스크에도 쓸 것인가 여부 - REDO

## REDO 정책

트랜잭션 커밋이 수정한 페이지의 디스크 반영을 의미하지는 않는다.

버퍼 관리 정책

- FORCE
    - 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영
    - 데이터베이스 백업으로부터의 복구 시에는 REDO 복구가 요구된다.
- ¬FORCE ⭐️
    - 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는다
    - 어떤 일들을 했었는지에 대한 로그는 기록한다.
    - 커밋한 트랜잭션 `내용이 디스크 상의 데이터베이스 상에 반영되어 있지 않을 수 있다.`
    - REDO 복구가 반드시 필요.

## 로그 기법

- UNDO와 REDO 복구를 위해서 가장 널리 쓰이는 구조
- 로그
    - 로그 레코드의 연속, 데이터베이스의 모든 갱신 작업을 기록
- DBMS는 성능 상의 이유로 하나의 로그를 유지
- 로그는 덧붙이는 방식으로 기록된다.
- 각 로그 레코드는 고유의 식별자를 가진다.
    - 로그 식별자 - LSN(Log Sequence Number), LSA(Log Sequence Address)
    - 로그는 항상 뒤에 덧붙이는 방식
        - 로그 식별자는 단조 증가하는 성질을 가진다.

## 물리적인 상태 로깅

- DBMS에서 가정 널리 쓰이는 기본적 로깅 방법
- 로그 레코드는 갱신 이전, 이후 이미지를 모두 가지고 있다.
- UNDO 복구
    - 이전 이미지로 현재 이미지를 대체
- REDO 복구
    - 이후 이미지를 반영하여 복구

## 로그가 쓰이는 규칙

- WAL (Write Ahead Logging)
    - 데이터를 업데이트하기 전에 관련 정보를 먼저 로그에 기록하는 것.
    - 업데이트가 데이터베이스에 써지기 전에 먼저 관련된 UNDO 정보가 로그에 써져야 한다.
- 트랜잭션이 정상적으로 종료 처리되기 위해서는 먼저 REDO 정보가 로그에 써져야 한다.

- 로그 버퍼
    - DBMS가 `로그 레코드를 관리`하기 위해 유지하는 버퍼
    - 로그 버퍼를 통해서 로그 파일에 입출력한다
    - 로그 버퍼에 로그 레코드를 모았다가 블록 단위로 로그 파일에 출력 (성능 개선)

- 여러 트랜잭션이 동시에 수행 하면서 각각의 로그 레코드가 생성된다.
- 로그 래코드는 로그 버퍼에 유지된다.
- 로그 레코드는 몇몇 시점에 로그 파일에 써지게 된다.
- 로그 버퍼에 유지된 레코드는...
    - 어떤 트랜잭션이 커밋 요청한 경우
    - WAL을 해야 하는 경우
    - 로그 버퍼가 다 소진된 경우
    - DBMS가 내부적으로 필요로 하는 경우
      에 로그 파일에 출력된다.

로그버퍼는 상대적으로 작아서 긴 트랜잭션이 수행 중인 경우에는 로그 버퍼가 소진될 수 있다.

로그 버퍼는 스택 형태로, 어떤 트랜잭션이 커밋을 요청하면 해당 트랜잭션의 마지막 로그 레코드까지 출력하면 된다.

예) 트랜잭션 T1이 커밋할 때 LSN3까지의 로그 레코드가 로그 파일에 출력되야 한다.

![dbms2](https://d2.naver.com/content/images/2015/06/helloworld-407507-2.png)


로그 레코드는 데이터베이스 복구를 위한 중요한 정보이기 때문에 로그 레코드를 안전하게 쓰는 것이 필요하다.
DBMS는 안전하게 로그를 쓰기 위해서 `write` 함수와 `fsync`함수를 호출한다.

## 로그 쓰는 일이 느린 이유

- fsync 함수는 느리다
- 트랜잭션 커밋을 위해서는 해당 트랜잭션의 로그가 로그 파일에 써져야 한다.
    - 커밋을 하려는 트랜잭션은 fsync 함수 호출이 종료되기를기다려야 한다.
- 로그버퍼를 쓸 때 로그 헤더 정보와 로그 레코드를 써야한다.
- 커밋 연산이 소모하는 대부분의 시간은 로그 레코드를 파일에 쓰고 fsync 함수를 실행하는 시간.
- 정확성을 위해 fsync 함수를 여러 차례 호출해야한다.
    - 로그 레코드를 쓰고 fsync 함수 실행
    - 로그 헤더 업데이트 후 fsync 함수 실행

## 로그 쓰기 작업 성능 개선 방법

### 1. 그룹 커밋

- 각각의 트랜잭션의 커밋 요구를 한번에 모아서 처리
- 디스크 출력 횟수를 줄일 수 있기 때문에 성능 향상
- 트랜잭션의  응답시간은 더 걸리더라도 시스템 전체의 처리량을 높인다.
    - 승용차 vs 고속 버스

### 2. 비동기 커밋

- 로그 버퍼에 로그 레코드 쓰고 바로 커밋을 완료
    - 로그 파일에 고르가 써질 때 까지 대기하지 않고 커밋
    - 로그 레코드는 비동기적으로 이후에 쓰인다.
        - 로그가 써지기 전에 장애 발생하면 커밋 완료 후에도 데이터 손실 발생.
        - 이를 방지하고자 복구시점에 해당 트랜잭션 커밋이 완료되지 않은것으로 간주하여 이를 롤백한다.

지속성을 일부 포기하고 매 커밋마다 로그를 쓰고 fsync 함수를 호출하는 대신 로그를 느슨하게 쓰는 방법.

## 특정 트랜잭션 철회 과정

- 역방향으로 로그를 탐색하면서 해당 트랜잭션의 UNDO 복구가 필요한 로그를 찾는다.
- UNDO 연산을 수행
- 트랜잭션 수행 순서의 역순으로 UNDO를 수행
- UNDO 수행후 CLR이라고 하는 REDO 전용 로그를 쓴다.
- CLR은 이전 로그 레코드의 위치를 UNDO 로그의 이전 로그를 가리키도록 한다.
    - UNDO후 UNDO를 다시해서 복구가 잘못되는걸 방지하기 위함
- 해당 트랜잭션의 시작 로그까지 계속 탐색



https://d2.naver.com/helloworld/407507
