> "Write once, run anywhere. 한 번 작성하면 어디서든 실행된다."

JVM은 Java 어플리케이션으로 부터 전달받은 바이트코드를 해당 OS아 이해할 수 있도록 변환하여 OS에 전달한다.

- JVM은 OS에 종속적이다.
- Java 어플리케이션은 JVM 덕분에 OS에 독립적이다.
- 한번 Java 코드를 작성하고 나면 다양한 OS에서 어플리케이션 실행이 가능.

![[스크린샷 2022-11-19 오후 8.07.57.png]]

- 바이트코드란?
    - JVM이 이해할 수 있는 기계어
    - 컴파일러는 자바 소스파일(.java)를 바이트코드(.class)로 변환한다.
    - JVM은 바이트코드를 해당 OS의 기계어로 변환하여 OS에 전달한다.
    - 바이트코드는 JRE 위에서 동작.
        - JRE는 자바 API와 JVM으로 구성.
        - JVM은 자바 어플리케이션을 Class Loader를 통해 읽어 들여서 자바 API와 함께 실행하는 것

### JVM 구성 요소

![[스크린샷 2022-11-20 오전 12.06.49.png]]
![[스크린샷 2022-11-20 오전 12.07.25.png]]

- Class Loader
    - 바이트코드를 메모리 상으로 로드한다.
        - 바이트코드(.class 파일)는 해당 클래스가 `실행될때` 메모리에 올라가게 된다.
        - 로딩(class 읽기), 링킹(class 검증), 초기화를 수행한다.
    - Loading
        - class loader가 필요한 class 파일들을 찾아서 탑재한다.
        - `기본으로 제공받은 클래스파일`, `개발자가 정의한 클래스 파일`인지에 따라서 class loader의 수준이 3가지로 나뉜다.
        - **Bootstrap ClassLoader**
            - 모든 ClassLoader의 최상위 부모
            - 가장 필수적인 라이브러리의 클래스들을 JVM에 탑재 -> `rt.jar`
            - OS에 맞는 네이티브 코드로 작성되어 있다.
        - **Extensions ClassLoader**
            - 표준 핵심 Java Class의 라이브러리들을 JVM에 탑재 -> `$JAVAHOME/jre/lib/ext_`
        - **Application ClassLoader**
            - 개발자들이 작성한 클래스들을 JVM에 탑재
        - 한번 JVM에 탑재된 클래스 파일은 종료까지 제거되지 않는다.
        - 하위 ClassLoader가 로딩한 클래스 파일은 상위 ClassLoader가 로딩한 클래스 파일을 볼 수 있다.
    - Linking
        - Load된 클래스 파일들을 검증하고, 사용 가능하도록 준비하는 과정
        - Verification, Preparation, Resolution으로 이루어진다.
        - **Verification 검증**
            - 클래스 파일이 JVM의 구동 조건 대로 구현되어있는지 확인
        - **Preparation 준비**
            - static 필드 메모리를 할당, 기본값으로 초기화 한다.
            - static 필드 값은 뒤의 초기화 과정에서 고드에 작성한 초기값으로 변경된다.
        - **Resolution 분석**
            - 클래스의 constant pool 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
                - 심볼릭 레퍼런스
                    - primitive 타입을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조.
    - 초기화
        - 클래스 변수들을 적절한 값으로 초기화
            - static 필드들을 설정된 값으로 초기화 한다.

- 런타임 데이터 영역
  ![[스크린샷 2022-11-20 오전 12.14.28.png]]
    - **메서드 영역 (PermGen - Oracle HotSpot JVM)**
        - 모든 스레드가 공유
        - JVM이 시작될 때 생성된다.
        - JVM이 읽어들인 클래스와 인터페이스에 대한 `런타임 상수 풀`,
            - 필드와 메서드 정보,
            - Static 변수
            - 메서드의 바이트코드 등을 보관
            - 런타임 상수 풀
                - 클래스와 인터페이스의 상수, 메서드와 필드에 대한 모든 레퍼런스를 담고 있는 테이블.
                - 메서드나 필드를 참조할때 JVM은 런타임 상수 풀을 통해 메서드나 필드의 실제 메모리상 주소를 찾아서 참조.
        - 메서드 영역의 클래스 정보로 힙 영역에 객체를 생성
    - 힙 영역
        - 모든 스레드가 공유
        - 객체와 인스턴스 변수, 배열이 저장된다.
    - 스택 영역
        - 각 쓰레드는 고유의 JVM 스택을 보유.
        - 지역 변수를 저장.
    - PC Register
        - 현재 수행중인 JVM 명령의 주소를 저장.
        - Context Switch 발생시 사용
    - Native Method Stack
        - 자바 이외의 언어로 작성된 코드가 할당된다.
- Execution Engine (실행 엔진)
    - 바이트코드를 명령어 단위로 읽어서 실행
    - **인터프리터**
        - 바이트코드 명령어를 하나씩 읽어서 해석하고 실행.
        - 하나씩 해석하고 실행하기 때문에 인터프리팅 결과의 실행은 느리다.
    - **JIT 컴파일러 (Just In Time)**
        - 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변환.
        - 이후, 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식
    - **AOT 컴파일러 (Ahead Of Time)**
        - 컴파일된 네이티브 코드를 공유 캐시를 통해 여러 JVM이 공유하는 것

## 자바 8에서 JVM 메모리 모델 변경 사항

- PermGen 영역이 없어지고 MetaSpace 공간으로 변경
- VM이 동적으로 MetaSpace 공간을 알아서 조절.
    - 과거엔 개발자가 세팅해 줘야 했음
      ![[스크린샷 2022-11-20 오전 1.01.05.png]]

- 클래스의 메서드 -> Native 영역으로
- 클래스의 Names -> Native 영역으로
- 상수 풀 정보 -> Heap 영역으로
- Static 변수 -> Heap 영역으로

### 참고자료

- https://brunch.co.kr/@myner/36
